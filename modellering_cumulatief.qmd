
# Cumulatief logistisch model


```{r cundateread}
#|message: false
#|cache: true
library(tidyverse)
library(brms)
library(agrmt)
library(pheatmap)
library(cluster)
library(dplyr)
library(emmeans)
library(corrplot)
library(INBOtheme)

conflicted::conflict_prefer_all(c("dplyr"), quiet = TRUE)
conflicted::conflict_prefer_all(c("purrr"), quiet = TRUE)
conflicted::conflict_prefer_all(c("tidyr"), quiet = TRUE)
conflicted::conflict_prefer_all(c("brms"), quiet = TRUE)

# Functie om kwantielen en gemiddelde te berekenen
quantile_and_mean <- function(x, probs = c(0.025, 0.5, 0.975), na.rm = TRUE, avg = TRUE) {
  quantiles <- quantile(x, probs = probs, na.rm = na.rm)
  mean_val <- mean(x, na.rm = na.rm)
  return(if(!avg) quantiles else c(quantiles, avg = mean_val))
}

inbo_palette <- INBOtheme::inbo_palette()
inbostyle_colors <- colorRampPalette(colors = inbo_palette()[1:3])

data_agg <- readRDS("interim/data_agg.rds")

data_cml <- data_agg |> 
  arrange(case_short, cluster_short, ess_short, f_score) |> 
  group_by(case_short, cluster_short, ess_short) |> 
  mutate(resp_cml = cumsum(n_responses),
         frac_cml = cumsum(n_responses) / sum(n_responses))

model_cml_simple <- readRDS("models/simplified_cumlogit_model.RDS")
model_cml_indiv <- readRDS("models/respondent_cumlogit_model.RDS")
```


Dit is volgens mij het meest correcte model om de data te modelleren. Er worden geen aannames gedaan over de verdeling van de data. Er wordt berekend wat de cumulatieve kans is op een score.
Dit betekent dat het model de kans berekent dat een ecosysteemdienst een bepaalde score of lager heeft, in plaats van de kans op een specifieke score te berekenen..

```{r simplfied_cumlogit_model}
#| cache: true

newdata_simpcl <- data_agg |> transmute(ess_short, cluster_short,  case_short = "global") |>
  distinct() |>
  mutate(rownr = row_number())

#haal fitted values op
fitted_summary <- fitted(model_cml_simple, newdata = newdata_simpcl, summary = TRUE, allow_new_levels = TRUE)
fitted_summary_s <-  fitted(model_cml_simple, newdata = newdata_simpcl, summary = FALSE, allow_new_levels = TRUE)

#sommeer de individuele (dimensie 3) scores tot een cumulatieve kans
summary_01 <- fitted_summary_s[,,1]
summary_12 <- fitted_summary_s[,,1] + fitted_summary_s[,,2]
summary_13 <- fitted_summary_s[,,1] + fitted_summary_s[,,2] + fitted_summary_s[,,3]
summary_14 <- fitted_summary_s[,,1] + fitted_summary_s[,,2] + fitted_summary_s[,,3] + fitted_summary_s[,,4]
summary_15 <- fitted_summary_s[,,1] + fitted_summary_s[,,2] + fitted_summary_s[,,3] + fitted_summary_s[,,4] + fitted_summary_s[,,5]

#maak de predicties
pred01 <- t(apply(summary_01, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(-1)",
         ess_short = newdata_simpcl |> pull(ess_short),
         cluster_short = newdata_simpcl |> pull(cluster_short))

pred12 <- t(apply(summary_12, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=0)",
         ess_short = newdata_simpcl |> pull(ess_short),
         cluster_short = newdata_simpcl |> pull(cluster_short))

pred13 <- t(apply(summary_13, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=1)",
         ess_short = newdata_simpcl |> pull(ess_short),
         cluster_short = newdata_simpcl |> pull(cluster_short))

pred14 <- t(apply(summary_14, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=2)",
         ess_short = newdata_simpcl |> pull(ess_short),
         cluster_short = newdata_simpcl |> pull(cluster_short))

pred15 <- t(apply(summary_15, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=3)",
         ess_short = newdata_simpcl |> pull(ess_short),
         cluster_short = newdata_simpcl |> pull(cluster_short))

predicties_clm <- bind_rows(pred01, pred12, pred13, pred14, pred15) |>
  mutate(value = factor(value, levels = rev(c("P(-1)", "P(<=0)", "P(<=1)", "P(<=2)", "P(<=3)"))))

estimates_clm <- fitted_summary[,1,] |>
  as.data.frame() |>
  mutate(ess_short = newdata_simpcl |> pull(ess_short),
         cluster_short = newdata_simpcl |> pull(cluster_short)) |>
  pivot_longer(cols = -c(ess_short, cluster_short), names_to = "value", values_to = "estimate") |>
  mutate(value = factor(value,
                        levels = c("P(Y = 3)", "P(Y = 2)", "P(Y = 1)", "P(Y = 0)", "P(Y = -1)"),
                        labels = c("P(<=3)","P(<=2)","P(<=1)","P(<=0)","P(-1)")))

```

```{r fig-simpcl_pred_plot}
#|fig.cap: "Results of the cumulative logistics model using all cases, but ignoring the respondent level effect."
#|fig.width: 7
#|fig.height: 10

ggplot(estimates_clm, aes(x = ess_short, y = estimate, fill = value)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_errorbar(data = predicties_clm,
                aes(ymin = `2.5%`, ymax = `97.5%`, x = ess_short, y = `50%`),
                position = position_dodge(0.8)) +
  geom_point(data = predicties_clm,
             aes(x = ess_short, y = avg),
             position = position_dodge(0.8)) +
  facet_wrap(~cluster_short, scales = "free_x", nrow = 2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.3, vjust = 0.5)) +
  scale_fill_manual(values = rev(RColorBrewer::brewer.pal(5, "RdYlBu"))) +
  labs(x = "ESS",
       y = "Estimated Probability",
       fill = "Score")
#ggsave("simplified_cumlogit_model_estimates.png", width = 7, height = 10)
```



```{r fig-simpcl_ran}
#|fig.cap: "Random effect estimates of the cumulative logistic model, in logit scale."

sdran <- VarCorr(model_cml_simple)
sdest <- round(sdran$case_short$sd[1,"Estimate"],2)
random_effects <- ranef(model_cml_simple)
# Extract random effects for each case
ranef_case <- random_effects$case[,,"Intercept"] |>
  as_tibble(rownames = "case") |>
  mutate(case = reorder(case, Estimate, mean, decreasing = TRUE))

ggplot(ranef_case, aes(x = case, y = Estimate, ymin = Q2.5, ymax = Q97.5)) +
  geom_point() +
  geom_errorbar() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(x = "Case", y = paste0("Random Effect Estimate")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```


## Cumulatief logistisch model op de individuele responses

```{r}
#| cache: true

newdata_cml <- model_cml_indiv$data |> 
  distinct(ess_short) |> 
  mutate(case_short = "global",
         respondent = 0) |>
  mutate(rownr = row_number()) 

#haal fitted values op
fitted_summary_ind <- fitted(model_cml_indiv, newdata = newdata_cml, summary = TRUE, allow_new_levels = TRUE)
fitted_summary_s_ind <-  fitted(model_cml_indiv, newdata = newdata_cml, summary = FALSE, allow_new_levels = TRUE)

#sommeer de individuele (dimensie 3) scores tot een cumulatieve kans
summary_01_ind <- fitted_summary_s_ind[,,1]
summary_12_ind <- fitted_summary_s_ind[,,1] + fitted_summary_s_ind[,,2]
summary_13_ind <- fitted_summary_s_ind[,,1] + fitted_summary_s_ind[,,2] + fitted_summary_s_ind[,,3]
summary_14_ind <- fitted_summary_s_ind[,,1] + fitted_summary_s_ind[,,2] + fitted_summary_s_ind[,,3] + fitted_summary_s_ind[,,4]
summary_15_ind <- fitted_summary_s_ind[,,1] + fitted_summary_s_ind[,,2] + fitted_summary_s_ind[,,3] + fitted_summary_s_ind[,,4] + fitted_summary_s_ind[,,5]

#maak de predicties
pred01_ind <- t(apply(summary_01_ind, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(-1)",
         ess_short = newdata_cml |> pull(ess_short))

pred12_ind <- t(apply(summary_12_ind, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=0)",
         ess_short = newdata_cml |> pull(ess_short))

pred13_ind <- t(apply(summary_13_ind, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=1)",
         ess_short = newdata_cml |> pull(ess_short))

pred14_ind <- t(apply(summary_14_ind, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=2)",
         ess_short = newdata_cml |> pull(ess_short))

pred15_ind <- t(apply(summary_15_ind, 2, quantile_and_mean, probs = c(0.025,0.500,0.975), na.rm = TRUE)) |>
  as.data.frame() |>
  mutate(value = "P(<=3)",
         ess_short = newdata_cml |> pull(ess_short))

predicties_clm_ind <- bind_rows(pred01_ind, pred12_ind, pred13_ind, pred14_ind, pred15_ind) |>
  mutate(value = factor(value, levels = rev(c("P(-1)", "P(<=0)", "P(<=1)", "P(<=2)", "P(<=3)")))) |> 
  left_join(data_respondent |> select(ess_short, cluster_short) |> distinct(),
            join_by(ess_short))


estimates_clm_ind <- fitted_summary_ind[,1,] |>
  as.data.frame() |>
  mutate(ess_short = newdata_cml |> pull(ess_short)) |>
  pivot_longer(cols = -c(ess_short), names_to = "value", values_to = "estimate") |>
  mutate(value = factor(value,
                        levels = c("P(Y = 3)", "P(Y = 2)", "P(Y = 1)", "P(Y = 0)", "P(Y = -1)"),
                        labels = c("P(<=3)","P(<=2)","P(<=1)","P(<=0)","P(-1)"))) |> 
  left_join(data_respondent |> select(ess_short, cluster_short) |> distinct(),
            join_by(ess_short))


```


```{r fig-indiv_pred_plot}
#|fig.cap: "Results of the cumulative logistics model using the cases with respondent level information, which is modelled."
#|fig.width: 7
#|fig.height: 10

ggplot(estimates_clm_ind, aes(x = ess_short, y = estimate, fill = value)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_errorbar(data = predicties_clm_ind,
                aes(ymin = `2.5%`, ymax = `97.5%`, x = ess_short, y = `50%`),
                position = position_dodge(0.8)) +
  geom_point(data = predicties_clm_ind,
             aes(x = ess_short, y = avg),
             position = position_dodge(0.8)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.3, vjust = 0.5)) +
  scale_fill_manual(values = rev(RColorBrewer::brewer.pal(5, "RdYlBu"))) +
  labs(x = "ESS",
       y = "Estimated Probability",
       fill = "Score") +
  facet_wrap(~cluster_short, scales = "free_x", nrow = 2)


#ggsave("simplified_cumlogit_model_estimates.png", width = 7, height = 10)
```




## Hurdle model

We kiezen ervoor de data niet via een hurdle model te analyseren. Een hurdle model in dit geval zou een model zijn waarbij de kans op een negatieve beoodeling wordt geschat, en dan het gemiddelde wordt gemodelleerd van de overgebleven scores.

In de data zijn het aantal negatieve beoordelingen echter zo laag, en heel specifiek maar voor 2 ecosysteemdiensten, waardoor dit model niet veel meerwaarde biedt dan een gewone beoordeling via het gemiddelde van de scores. Het meest correcte model met deze data is volgens mij het cumulatief logistische model, omdat dit de aard van de data het best benaderd, en de kans op een negatieve beoordeling zit hier ook impliciet in als de kans dat de score -1 is.




````{=html}

# Visualiseer de voorspellingen
hist(predictions, main = "Posterior Predictions", xlab = "Predicted Values", breaks = 30)
# Opslaan van het model
saveRDS(model, file = "hurdle_model.rds")
# Laad het model
loaded_model <- readRDS("hurdle_model.rds")
# Voorspel nieuwe waarden
new_data <- data.frame(region = unique(data$region))
predictions_new <- posterior_predict(loaded_model, newdata = new_data)
# Visualiseer de nieuwe voorspellingen
hist(predictions_new, main = "Posterior Predictions for New Data", xlab = "Predicted Values", breaks = 30)
# Opslaan van de voorspellingen
write.csv(predictions_new, file = "predictions_new.csv", row.names = FALSE)
# Evaluatie van het model
library(loo)
loo_result <- loo(model)
# Samenvatting van de LOO-criteria
print(loo_result)
# Visualiseer de LOO-criteria
plot(loo_result)
# Opslaan van de LOO-criteria
saveRDS(loo_result, file = "loo_result.rds")
# Laad de LOO-criteria
loaded_loo_result <- readRDS("loo_result.rds")
# Visualiseer de geladen LOO-criteria
plot(loaded_loo_result)
# Opslaan van de resultaten
saveRDS(list(model = model, predictions = predictions, loo_result = loo_result), file = "model_results.rds")
# Laad de resultaten
loaded_results <- readRDS("model_results.rds")
# Visualiseer de geladen resultaten
plot(loaded_results$model)
# Voorspel de waarden met de geladen resultaten
predictions_loaded <- posterior_predict(loaded_results$model)
# Visualiseer de voorspellingen van de geladen resultaten
hist(predictions_loaded, main = "Posterior Predictions from Loaded Model", xlab = "Predicted Values", breaks = 30)
# Opslaan van de voorspellingen van de geladen resultaten
write.csv(predictions_loaded, file = "predictions_loaded.csv", row.names = FALSE)
# Evaluatie van de voorspellingen
library(ggplot2)
ggplot(data = data.frame(predictions = predictions_loaded), aes(x = predictions)) +
  geom_histogram(bins = 30, fill = "blue", alpha = 0.7) +
  labs(title = "Histogram of Predictions from Loaded Model", x = "Predicted Values", y = "Frequency") +
  theme_minimal()
# Opslaan van de visualisatie
ggsave("predictions_histogram.png", width = 8, height = 6)
# Laad de visualisatie
predictions_histogram <- png::readPNG("predictions_histogram.png")
# Visualiseer de geladen histogram
grid::grid.raster(predictions_histogram)
# Opslaan van de geladen histogram
png::writePNG(predictions_histogram, "predictions_histogram_loaded.png")
# Laad de geladen histogram
loaded_predictions_histogram <- png::readPNG("predictions_histogram_loaded.png")
# Visualiseer de geladen histogram
grid::grid.raster(loaded_predictions_histogram)
# Opslaan van de geladen histogram
png::writePNG(loaded_predictions_histogram, "predictions_histogram_final.png")
# Laad de finale histogram
final_predictions_histogram <- png::readPNG("predictions_histogram_final.png")
# Visualiseer de finale histogram
grid::grid.raster(final_predictions_histogram)
# Opslaan van de finale histogram
png::writePNG(final_predictions_histogram, "predictions_histogram_final.png")
# Laad de finale histogram
final_predictions_histogram <- png::readPNG("predictions_histogram_final.png")
# Visualiseer de finale histogram
grid::grid.raster(final_predictions_histogram)
# Opslaan van de finale histogram
png::writePNG(final_predictions_histogram, "predictions_histogram_final.png")
# Laad de finale histogram
final_predictions_histogram <- png::readPNG("predictions_histogram_final.png")
# Visualiseer de finale histogram
grid::grid.raster(final_predictions_histogram)
# Opslaan van de finale histogram
```
-->
````
--->

